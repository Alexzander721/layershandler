# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Delivery
                                 A QGIS plugin
 Обработка слоёв для сдачи
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-03-23
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Travin Alexzander
        email                : Alexzander721@mail.ru
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from PyQt5 import QtWidgets
from PyQt5.QtCore import Qt
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox, QCheckBox
import processing
from qgis.core import (QgsApplication,
                       QgsProject,
                       QgsCoordinateReferenceSystem,
                       QgsCoordinateTransform,
                       QgsField,
                       QgsFields,
                       QgsFeature,
                       QgsVectorDataProvider,
                       QgsVectorLayer,
                       QgsVectorFileWriter,
                       QgsWkbTypes,
                       QgsVectorLayerUtils,
                       QgsMapLayerType,
                       QgsMapLayer,
                       )
from .resources import *
from .library import *
from .Layer_del_dialog import DeliveryDialog
import time
import os


def message(tip, text):
    """Вывод информационных сообщений"""
    error_msg = QMessageBox()
    error_msg.setWindowTitle(tip)
    error_msg.setText(text)
    error_msg.exec_()


def change(layer, fldname, text):
    """Заполнение полей"""
    for feature in layer.getFeatures():
        layer.dataProvider().changeAttributeValues(
            {feature.id(): {layer.dataProvider().fieldNameIndex(f"{fldname}"): text}})


def universal(layer, catalog, ilst, fld, lst):
    """Объеденение всех объектов на слое, заполнение поля категории"""
    processing.run(
        "native:dissolve",
        {'INPUT': layer,
         'FIELD': [],
         'OUTPUT': f"{catalog}/{layer.name()}.gpkg"})
    vlr = QgsVectorLayer(f"{catalog}/{layer.name()}.gpkg", f"{ilst}", "ogr")
    vlr.dataProvider().addAttributes(
        [QgsField(fld, QVariant.String, len=30)]), vlr.updateFields()
    lst.append(vlr)
    try:
        [vlr.dataProvider().changeAttributeValues(
            {feature.id(): {vlr.dataProvider().fieldNameIndex(fld): ilst}}) for feature in vlr.getFeatures()]
    except IndexError:
        pass
    return lst


def remove_old_file(path):
    """Удаление старого файла"""
    if os.path.exists(path) and os.path.isfile(path):
        if time.time() - os.stat(path)[7] > 86400:
            os.remove(path)


def tr(msg):
    """Перевод"""
    return QCoreApplication.translate('Delivery', msg)


class Delivery:
    """Класс модуля обработки"""

    def __init__(self, iface):
        self.iface = iface
        self.instance = QgsProject.instance()
        self.plugin_dir = os.path.dirname(__file__)
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Delivery_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        self.actions = []
        self.menu = tr(u'&Обработка слоёв')
        self.first_start = None

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Включает плагин"""
        icon_path = ':/plugins/Layer_del/icon.png'
        self.add_action(
            icon_path,
            text=tr(u'Подготовка слоёв'),
            callback=self.run,
            parent=self.iface.mainWindow())

        self.first_start = True

    def unload(self):
        """Отключает плагин"""
        for action in self.actions:
            self.iface.removePluginMenu(
                tr(u'&Обработка слоёв'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Запуск основных процессов"""
        self.dlg = DeliveryDialog()
        self.Projection = self.dlg.mQgsProjectionSelectionWidget
        self.dlg.lineEdit.clear()
        self.dlg.toolButton.clicked.connect(self.dct)
        self.dlg.OK.clicked.connect(self.apply)
        self.dlg.Cancel.clicked.connect(self.cancel)
        self.dlg.exportAll.clicked.connect(self.list_layer)
        self.dlg.crs.clicked.connect(self.set_crs)
        self.Projection.setCrs(self.instance.crs())
        self.dlg.tabWidget.setCurrentIndex(0)
        self.dlg.Shape.setChecked(True)
        self.choice_layer()
        self.list_layer()
        remove_old_file(f"{self.plugin_dir}/values.tmp")
        self.values()
        self.dlg.show()

    def choice_layer(self):
        """Выбор слоя"""
        self.dlg.comboBox.clear()
        [self.dlg.comboBox.addItem(layer.name(), layer) for layer in self.instance.mapLayers().values()
         if layer.type() == 0 and layer.geometryType() == 2 and "ВЫДЕЛ" in layer.name().upper()]

    def list_layer(self):
        "Заполнение listWidget слоями"
        self.dlg.listWidget.clear()
        for layer in self.instance.mapLayers().values():
            if layer.type() == 0:
                item = QtWidgets.QListWidgetItem(layer.name())
                item.setData(QtCore.Qt.ToolTipRole, layer)
                item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
                self.dlg.listWidget.addItem(item)
                if not self.dlg.exportAll.isChecked():
                    item.setCheckState(Qt.Unchecked)
                elif self.dlg.exportAll.isChecked():
                    item.setCheckState(Qt.Checked)

    def apply(self):
        """Запуск алгоритмов обработки, проверка на ошибки"""
        linelayer = []
        if self.dlg.tabWidget.currentIndex() == 0:
            if not self.dlg.Contract.text().strip():
                message("Ошибка!", f"Поле {self.dlg.label_2.text()} не заполнено!")
            if not self.dlg.Subject.text().strip():
                message("Ошибка!", f"Поле {self.dlg.label_4.text()} не заполнено!")
            if not self.dlg.Forestry.text().strip():
                message("Ошибка!", f"Поле {self.dlg.label_5.text()} не заполнено!")
            if not self.dlg.District.text().strip():
                message("Ошибка!", f"Поле {self.dlg.label_6.text()} не заполнено!")
            else:
                if not self.dlg.lineEdit.text():
                    message("Ошибка!", "Папка назначения не задана!")
                elif self.dlg.lineEdit.text():
                    self.write()
                    os.mkdir(f"{self.dlg.lineEdit.text()}/готово/")
                    self.borders()
                    [self.saveSHP(self.dlg.lineEdit.text(), layer)
                     for layer in self.iface.mapCanvas().layers() if layer.type() == 0]
                    [self.remove(self.dlg.lineEdit.text(), layer)
                     for layer in self.iface.mapCanvas().layers() if layer.type() == 0]
                    self.instance.addMapLayer(
                        QgsVectorLayer(f"{self.dlg.lineEdit.text()}/готово/Границы квартальной сети.shp",
                                       "Границы квартальной сети", "ogr"))
                    self.instance.addMapLayer(
                        QgsVectorLayer(f"{self.dlg.lineEdit.text()}/готово/Границы объекта работ.shp",
                                       "Границы объекта работ", "ogr"))
                    self.instance.addMapLayer(
                        QgsVectorLayer(f"{self.dlg.lineEdit.text()}/готово/Границы повыделенной сети.shp",
                                       "Границы повыделенной сети", "ogr"))
                    [self.field(layer) for layer in self.instance.mapLayers().values() if layer.type() == 0]
                    self.KCN(self.dlg.lineEdit.text())
                    self.OZU(self.dlg.lineEdit.text())
                    self.poligonlinesLES(self.dlg.lineEdit.text())
                    self.poligonlines(self.dlg.lineEdit.text())
                    self.infrlinesLES(self.dlg.lineEdit.text(), linelayer)
                    self.infrlines(self.dlg.lineEdit.text(), linelayer)
                    self.gidrolines(self.dlg.lineEdit.text(), linelayer)
                    self.gidroarea(self.dlg.lineEdit.text())
                    self.lines(self.dlg.lineEdit.text(), linelayer)
                    message("Готово!", f"Результирующие слои сохранены в папке: {self.dlg.lineEdit.text()}/готово/")
                    self.dlg.close()
        elif self.dlg.tabWidget.currentIndex() == 1:
            if not self.dlg.lineEdit.text():
                message("Ошибка!", "Папка назначения не задана!")
            if not self.dlg.Shape.isChecked() and not self.dlg.MapInfo.isChecked() and not self.dlg.GeoPackage.isChecked():
                message("Выберите тип файла!", "Не выбран тип выходного файла! (Shape, MapInfo, GeoPackage)")
            elif self.dlg.lineEdit.text():
                self.save(self.dlg.lineEdit.text())
                message("Готово!", f"Результирующие слои сохранены в папке: {self.dlg.lineEdit.text()}")
                self.dlg.close()

    def borders(self):
        """Создание границ объекта и полигонов кварталов"""
        processing.run(
            "native:dissolve",
            {'INPUT': self.dlg.comboBox.itemData(self.dlg.comboBox.currentIndex()),
             'FIELD': 'KW',
             'OUTPUT': f"{self.dlg.lineEdit.text()}/готово/Границы квартальной сети.shp"})
        processing.run(
            "native:dissolve",
            {'INPUT': self.dlg.comboBox.itemData(self.dlg.comboBox.currentIndex()),
             'FIELD': [],
             'OUTPUT': f"{self.dlg.lineEdit.text()}/готово/Границы объекта работ.shp"})

    def saveSHP(self, catalog, layer):
        """
        Сохранение слоёв в ESRI Shapefile СК WGS84
        """
        if layer.name() == (self.dlg.comboBox.itemData(self.dlg.comboBox.currentIndex())).name():
            QgsVectorFileWriter.writeAsVectorFormat(self.dlg.comboBox.itemData(self.dlg.comboBox.currentIndex()),
                                                    f"{self.dlg.lineEdit.text()}/готово/Границы повыделенной сети.shp",
                                                    'windows-1251',
                                                    QgsCoordinateTransform(QgsCoordinateReferenceSystem("EPSG:4326"),
                                                                           QgsCoordinateReferenceSystem("EPSG:4326"),
                                                                           self.instance), "ESRI Shapefile")
        QgsVectorFileWriter.writeAsVectorFormat(layer, f"{catalog}/WGS84_{layer.name()}", 'windows-1251',
                                                QgsCoordinateTransform(
                                                    QgsCoordinateReferenceSystem("EPSG:4326"),
                                                    QgsCoordinateReferenceSystem("EPSG:4326"),
                                                    self.instance), "ESRI Shapefile")

    def save(self, catalog):
        "сохранение слоёв"
        cname = format(self.Projection.crs().description())
        cname = cname.replace(" ", "").replace("/", "-")
        if not os.path.exists(f"{catalog}/WGS84"):
            os.mkdir(f"{catalog}/WGS84/")
        if not os.path.exists(f"{catalog}/{cname}"):
            os.mkdir(f"{catalog}/{cname}/")
        if self.dlg.Shape.isChecked():
            if not os.path.exists(f"{catalog}/WGS84/SHP"):
                os.mkdir(f"{catalog}/WGS84/SHP")
            if not os.path.exists(f"{catalog}/{cname}/SHP"):
                os.mkdir(f"{catalog}/{cname}/SHP")
        if self.dlg.MapInfo.isChecked():
            if not os.path.exists(f"{catalog}/WGS84/MapInfo"):
                os.mkdir(f"{catalog}/WGS84/MapInfo")
            if not os.path.exists(f"{catalog}/{cname}/MapInfo"):
                os.mkdir(f"{catalog}/{cname}/MapInfo")
        if self.dlg.GeoPackage.isChecked():
            if not os.path.exists(f"{catalog}/WGS84/GeoPackage"):
                os.mkdir(f"{catalog}/WGS84/GeoPackage")
            if not os.path.exists(f"{catalog}/{cname}/GeoPackage"):
                os.mkdir(f"{catalog}/{cname}/GeoPackage")
        for item in [self.dlg.listWidget.item(x) for x in range(self.dlg.listWidget.count())]:
            if item.checkState() == 2:
                if self.dlg.Shape.isChecked():
                    QgsVectorFileWriter.writeAsVectorFormat(item.data(3),
                                                            f"{catalog}/WGS84/SHP/{item.data(3).name()}.shp",
                                                            'windows-1251',
                                                            QgsCoordinateTransform(item.data(3).crs(),
                                                                                   QgsCoordinateReferenceSystem(
                                                                                       "EPSG:4326"), self.instance),
                                                            "ESRI Shapefile")
                    QgsVectorFileWriter.writeAsVectorFormat(item.data(3),
                                                            f"{catalog}/{cname}/SHP/{item.data(3).name()}.shp",
                                                            'windows-1251',
                                                            QgsCoordinateTransform(item.data(3).crs(),
                                                                                   self.Projection.crs(),
                                                                                   self.instance), "ESRI Shapefile")
                if self.dlg.MapInfo.isChecked():
                    QgsVectorFileWriter.writeAsVectorFormat(item.data(3),
                                                            f"{catalog}/WGS84/MapInfo/{item.data(3).name()}.TAB",
                                                            'windows-1251',
                                                            QgsCoordinateTransform(item.data(3).crs(),
                                                                                   QgsCoordinateReferenceSystem(
                                                                                       "EPSG:4326"), self.instance),
                                                            "MapInfo File")
                    QgsVectorFileWriter.writeAsVectorFormat(item.data(3),
                                                            f"{catalog}/WGS84/MapInfo/{item.data(3).name()}.TAB",
                                                            'windows-1251',
                                                            QgsCoordinateTransform(item.data(3).crs(),
                                                                                   self.Projection.crs(),
                                                                                   self.instance), "MapInfo File")
                if self.dlg.GeoPackage.isChecked():
                    QgsVectorFileWriter.writeAsVectorFormat(item.data(3),
                                                            f"{catalog}/WGS84/GeoPackage/{item.data(3).name()}.gpkg",
                                                            'windows-1251',
                                                            QgsCoordinateTransform(item.data(3).crs(),
                                                                                   QgsCoordinateReferenceSystem(
                                                                                       "EPSG:4326"), self.instance),
                                                            "GPKG")
                    QgsVectorFileWriter.writeAsVectorFormat(item.data(3),
                                                            f"{catalog}/WGS84/GeoPackage/{item.data(3).name()}.gpkg",
                                                            'windows-1251',
                                                            QgsCoordinateTransform(item.data(3).crs(),
                                                                                   self.Projection.crs(),
                                                                                   self.instance), "GPKG")

    def remove(self, catalog, layer):
        """Удаление слоёв MIF открытие сохранёных SHP файлов"""
        self.instance.addMapLayer(
            QgsVectorLayer(f"{catalog}/WGS84_{layer.name()}.shp", f"{layer.name()}",
                           "ogr"))
        self.instance.removeMapLayer(layer)

    def field(self, layer):
        """Создание и заполнение полей, удаление ненужных"""
        if layer.geometryType() == 2:
            if layer.name() == 'Границы повыделенной сети':
                layer.dataProvider().deleteAttributes([layer.dataProvider().fieldNameIndex("AREA")])
                self.createFilds(layer)
            if layer.name() == 'Границы квартальной сети':
                layer.dataProvider().deleteAttributes(([layer.dataProvider().fieldNameIndex("AREA"),
                                                        layer.dataProvider().fieldNameIndex("VD"),
                                                        layer.dataProvider().fieldNameIndex("PVD")]))
                self.createFilds(layer)
            if layer.name() == 'Границы объекта работ':
                layer.dataProvider().deleteAttributes(([layer.dataProvider().fieldNameIndex("AREA"),
                                                        layer.dataProvider().fieldNameIndex("VD"),
                                                        layer.dataProvider().fieldNameIndex("KW"),
                                                        layer.dataProvider().fieldNameIndex("PVD")]))
                self.createFilds(layer)
            if layer.name() in ('КЦН', 'ОЗУ', 'Объекты лесной инфраструктуры полигоны',
                                "Объекты нелесной инфраструктуры полигоны", 'Объекты гидрологической сети полигоны'):
                layer.dataProvider().deleteAttributes(([layer.dataProvider().fieldNameIndex("AREA"),
                                                        layer.dataProvider().fieldNameIndex("VD"),
                                                        layer.dataProvider().fieldNameIndex("KW"),
                                                        layer.dataProvider().fieldNameIndex("PVD"),
                                                        layer.dataProvider().fieldNameIndex("layer"),
                                                        layer.dataProvider().fieldNameIndex("fid"),
                                                        layer.dataProvider().fieldNameIndex("path")]))
                self.createFilds(layer)
        if layer.geometryType() == 1:
            if layer.name() in ('Объекты лесной инфраструктуры линии', 'Объекты нелесной инфраструктуры линии',
                                'Объекты гидрологической сети'):
                layer.dataProvider().deleteAttributes(([layer.dataProvider().fieldNameIndex("AREA"),
                                                        layer.dataProvider().fieldNameIndex("VD"),
                                                        layer.dataProvider().fieldNameIndex("KW"),
                                                        layer.dataProvider().fieldNameIndex("PVD"),
                                                        layer.dataProvider().fieldNameIndex("layer"),
                                                        layer.dataProvider().fieldNameIndex("path"),
                                                        layer.dataProvider().fieldNameIndex("fid"),
                                                        layer.dataProvider().fieldNameIndex("Info")]))
                self.createFilds(layer)
            if layer.name() == 'Линейные объекты':
                layer.dataProvider().deleteAttributes(([layer.dataProvider().fieldNameIndex("layer"),
                                                        layer.dataProvider().fieldNameIndex("path")]))
        layer.updateFields()

    def createFilds(self, layer):
        """Создание полей сведений об объекте"""
        layer.dataProvider().addAttributes(
            [QgsField("Субъект", QVariant.String, len=30), QgsField("Лесничеств", QVariant.String, len=30),
             QgsField("Участковое", QVariant.String, len=30), QgsField("Договор", QVariant.String, len=40)])
        layer.updateFields()
        self.textbase(layer)

    def textbase(self, layer):
        """Перебор полей сведений об объекте"""
        for fldname in ("Субъект", "Лесничеств", "Участковое", "Договор"):
            if fldname == "Субъект":
                text = self.dlg.Subject.text()
                change(layer, fldname, text)
            if fldname == "Лесничеств":
                text = self.dlg.Forestry.text()
                change(layer, fldname, text)
            if fldname == "Участковое":
                text = self.dlg.District.text()
                change(layer, fldname, text)
            if fldname == "Договор":
                text = self.dlg.Contract.text()
                change(layer, fldname, text)
        layer.updateFields()

    def KCN(self, catalog):
        """Создание границ КЦН"""
        lst = []
        for layer in self.instance.mapLayers().values():
            if layer.type() == 0 and layer.geometryType() == 2:
                [universal(layer, catalog, kcn[i], "Кат_защ", lst) for i in kcn.keys() if
                 i in layer.name().upper()]
        if lst:
            processing.run("native:mergevectorlayers",
                           {'CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
                            'LAYERS': lst,
                            'OUTPUT': f"{catalog}/готово/КЦН.shp"})
            self.field(QgsVectorLayer(f"{catalog}/готово/КЦН.shp", "КЦН", "ogr"))
            self.instance.addMapLayer(QgsVectorLayer(f"{catalog}/готово/КЦН.shp", "КЦН", "ogr"))

    def OZU(self, catalog):
        """Создание границ ОЗУ"""
        lst = []
        for layer in self.instance.mapLayers().values():
            if layer.type() == 0 and layer.geometryType() == 2:
                [universal(layer, catalog, ozu[i], "ОЗУ", lst) for i in ozu.keys() if i in layer.name().upper()]
        if lst:
            processing.run("native:mergevectorlayers",
                           {'CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
                            'LAYERS': lst,
                            'OUTPUT': f"{catalog}/готово/Границы особо защитных участков.shp"})
            self.field(QgsVectorLayer(f"{catalog}/готово/Границы особо защитных участков.shp", "ОЗУ", "ogr"))
            self.instance.addMapLayer(
                QgsVectorLayer(f"{catalog}/готово/Границы особо защитных участков.shp", "ОЗУ", "ogr"))

    def poligonlinesLES(self, catalog):
        """Объекты лесной инфраструктуры полигоны"""
        lst = []
        for layer in self.instance.mapLayers().values():
            if layer.name() in ["Границы квартальной сети", "Границы объекта работ", "Границы повыделенной сети"]:
                pass
            else:
                if layer.type() == 0 and layer.geometryType() == 2:
                    [universal(layer, catalog, infrles[i], "Кат_зем", lst) for i in infrles.keys() if
                     i in layer.name().upper()]
        if lst:
            processing.run("native:mergevectorlayers",
                           {'CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
                            'LAYERS': lst,
                            'OUTPUT': f"{catalog}/готово/Объекты лесной инфраструктуры полигоны.shp"})
            self.field(QgsVectorLayer(f"{catalog}/готово/Объекты лесной инфраструктуры полигоны.shp",
                                      "Объекты лесной инфраструктуры полигоны", "ogr"))
            self.instance.addMapLayer(QgsVectorLayer(f"{catalog}/готово/Объекты лесной инфраструктуры полигоны.shp",
                                                     "Объекты лесной инфраструктуры полигоны", "ogr"))

    def poligonlines(self, catalog):
        """Объекты нелесной инфраструктуры полигоны"""
        lst = []
        for layer in self.instance.mapLayers().values():
            if layer.name() in ["Границы квартальной сети", "Границы объекта работ", "Границы повыделенной сети"]:
                pass
            else:
                if layer.type() == 0 and layer.geometryType() == 2:
                    [universal(layer, catalog, infr[i], "Кат_зем", lst) for i in infr.keys() if
                     i in layer.name().upper()]
        if lst:
            processing.run("native:mergevectorlayers",
                           {'CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
                            'LAYERS': lst,
                            'OUTPUT': f"{catalog}/готово/Объекты нелесной инфраструктуры полигоны.shp"})
            self.field(QgsVectorLayer(f"{catalog}/готово/Объекты нелесной инфраструктуры полигоны.shp",
                                      "Объекты нелесной инфраструктуры полигоны", "ogr"))
            self.instance.addMapLayer(QgsVectorLayer(f"{catalog}/готово/Объекты нелесной инфраструктуры полигоны.shp",
                                                     "Объекты нелесной инфраструктуры полигоны", "ogr"))

    def infrlinesLES(self, catalog, linelayer):
        """Объекты лесной инфраструктуры линии"""
        lst = []
        for layer in self.instance.mapLayers().values():
            if layer.type() == 0 and layer.geometryType() == 1:
                if layer.name().upper() == "КВ ПРОСЕКИ":
                    universal(layer, catalog, "Квартальные просеки", "Кат_зем", lst)
                if layer.name().upper() == "КВ ПРОСЕКИ ЕСТ" or layer.name().upper() == "КВ ПР ПО КАНАВАМ":
                    universal(layer, catalog, "Кв пр по естеств руб", "Кат_зем", lst)
                [universal(layer, catalog, infrles[i], "Кат_зем", lst) for i in infrles.keys() if
                 i in layer.name().upper()]
        if lst:
            processing.run("native:mergevectorlayers",
                           {'CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
                            'LAYERS': lst,
                            'OUTPUT': f"{catalog}/готово/Объекты лесной инфраструктуры линии.shp"})
            self.field(
                QgsVectorLayer(f"{catalog}/готово/Объекты лесной инфраструктуры линии.shp",
                               "Объекты лесной инфраструктуры линии", "ogr"))
            self.instance.addMapLayer(QgsVectorLayer(f"{catalog}/готово/Объекты лесной инфраструктуры линии.shp",
                                                     "Объекты лесной инфраструктуры линии", "ogr"))
            linelayer.append(f"{catalog}/готово/Объекты лесной инфраструктуры линии.shp")
            return linelayer

    def infrlines(self, catalog, linelayer):
        """Объекты нелесной инфраструктуры линии"""
        lst = []
        for layer in self.instance.mapLayers().values():
            if layer.type() == 0 and layer.geometryType() == 1:
                [universal(layer, catalog, infr[i], "Кат_зем", lst) for i in infr.keys() if i in layer.name().upper()]
        if lst:
            processing.run("native:mergevectorlayers",
                           {'CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
                            'LAYERS': lst,
                            'OUTPUT': f"{catalog}/готово/Объекты нелесной инфраструктуры линии.shp"})
            self.field(
                QgsVectorLayer(f"{catalog}/готово/Объекты нелесной инфраструктуры линии.shp",
                               "Объекты нелесной инфраструктуры линии", "ogr"))
            self.instance.addMapLayer(QgsVectorLayer(f"{catalog}/готово/Объекты нелесной инфраструктуры линии.shp",
                                                     "Объекты нелесной инфраструктуры линии", "ogr"))
            linelayer.append(f"{catalog}/готово/Объекты нелесной инфраструктуры линии.shp")
            return linelayer

    def gidrolines(self, catalog, linelayer):
        """Объекты гидрологической сети"""
        lst = []
        for layer in self.instance.mapLayers().values():
            if layer.type() == 0 and layer.geometryType() == 1:
                [universal(layer, catalog, gidr[i], "Кат_зем", lst) for i in gidr.keys() if i in layer.name().upper()]
        if lst:
            processing.run("native:mergevectorlayers",
                           {'CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
                            'LAYERS': lst,
                            'OUTPUT': f"{catalog}/готово/Объекты гидрологической сети.shp"})
            self.field(
                QgsVectorLayer(f"{catalog}/готово/Объекты гидрологической сети.shp", "Объекты гидрологической сети",
                               "ogr"))
            self.instance.addMapLayer(
                QgsVectorLayer(f"{catalog}/готово/Объекты гидрологической сети.shp", "Объекты гидрологической сети",
                               "ogr"))
            linelayer.append(f"{catalog}/готово/Объекты гидрологической сети.shp")
            return linelayer

    def gidroarea(self, catalog):
        """Объекты гидрологической сети полигональные"""
        lst = []
        for layer in self.instance.mapLayers().values():
            if layer.type() == 0 and layer.geometryType() == 2:
                [universal(layer, catalog, gidr[i], "Кат_зем", lst) for i in gidr.keys() if i in layer.name().upper()]
        if lst:
            processing.run("native:mergevectorlayers",
                           {'CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
                            'LAYERS': lst,
                            'OUTPUT': f"{catalog}/готово/Объекты гидрологической сети полигоны.shp"})
            self.field(QgsVectorLayer(f"{catalog}/готово/Объекты гидрологической сети полигоны.shp",
                                      "Объекты гидрологической сети полигоны", "ogr"))
            self.instance.addMapLayer(QgsVectorLayer(f"{catalog}/готово/Объекты гидрологической сети полигоны.shp",
                                                     "Объекты гидрологической сети полигоны", "ogr"))

    def lines(self, catalog, linelayer):
        """Объеденение линейных слоёв"""
        if len(linelayer) > 0:
            processing.run("native:mergevectorlayers",
                           {'CRS': QgsCoordinateReferenceSystem('EPSG:4326'),
                            'LAYERS': linelayer,
                            'OUTPUT': f"{catalog}/готово/Линейные объекты.shp"})
            self.field(QgsVectorLayer(f"{catalog}/готово/Линейные объекты.shp", "Линейные объекты", "ogr"))
            self.instance.addMapLayer(
                QgsVectorLayer(f"{catalog}/готово/Линейные объекты.shp", "Линейные объекты", "ogr"))

    def set_crs(self):
        """Установка для слоёв MIF СК WGS84"""
        for layer in self.instance.mapLayers().values():
            if layer.type() == 0:
                layer.setCrs(QgsCoordinateReferenceSystem('EPSG:4326')), layer.triggerRepaint()

    def write(self):
        "Запись значений в файл .tmp"
        with open(f"{self.plugin_dir}/values.tmp", 'w', encoding='cp1251') as file:
            file.writelines(
                [f"{self.dlg.Contract.text()}\n",
                 f"{self.dlg.checkBox_1.isChecked()}\n",
                 f"{self.dlg.Subject.text()}\n",
                 f"{self.dlg.checkBox_2.isChecked()}\n",
                 f"{self.dlg.Forestry.text()}\n",
                 f"{self.dlg.checkBox_3.isChecked()}\n",
                 f"{self.dlg.District.text()}\n",
                 f"{self.dlg.checkBox_4.isChecked()}"])

    def values(self):
        "Чтение и подстановка значений из файла .tmp"
        self.dlg.Contract.clear(), self.dlg.Subject.clear(), self.dlg.Forestry.clear(), self.dlg.District.clear()
        if os.path.exists(f"{self.plugin_dir}/values.tmp") and os.stat(f"{self.plugin_dir}/values.tmp").st_size != 0:
            with open(f"{self.plugin_dir}/values.tmp", 'r', encoding='cp1251') as file:
                text = file.readlines()
                if text[1][:-1] == str(True):
                    self.dlg.checkBox_1.setChecked(True)
                    self.dlg.Contract.setText(text[0][:-1])
                else:
                    self.dlg.checkBox_1.setChecked(False)
                if text[3][:-1] == str(True):
                    self.dlg.checkBox_2.setChecked(True)
                    self.dlg.Subject.setText(text[2][:-1])
                else:
                    self.dlg.checkBox_2.setChecked(False)
                if text[5][:-1] == str(True):
                    self.dlg.checkBox_3.setChecked(True)
                    self.dlg.Forestry.setText(text[4][:-1])
                else:
                    self.dlg.checkBox_3.setChecked(False)
                if text[7] == str(True):
                    self.dlg.checkBox_4.setChecked(True)
                    self.dlg.District.setText(text[6][:-1])
                else:
                    self.dlg.checkBox_4.setChecked(False)
        elif not os.path.exists(
                f"{self.plugin_dir}/values.tmp") or os.stat(f"{self.plugin_dir}/values.tmp").st_size == 0:
            with open(f"{self.plugin_dir}/values.tmp", 'w', encoding='cp1251') as file:
                file.writelines(
                    ["Введите значение\n",
                     f"{self.dlg.checkBox_1.isChecked()}\n",
                     "Введите значение\n",
                     f"{self.dlg.checkBox_2.isChecked()}\n",
                     "Введите значение\n",
                     f"{self.dlg.checkBox_3.isChecked()}\n",
                     "Введите значение\n",
                     f"{self.dlg.checkBox_4.isChecked()}"])

    def dct(self):
        """Выбор каталога сохранения"""
        self.dlg.lineEdit.setText(QFileDialog.getExistingDirectory())

    def cancel(self):
        """Закрытие окна программы"""
        self.dlg.close()
